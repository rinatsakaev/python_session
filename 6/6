Узнать количество ссылок на объект:
import sys
sys.getrefcount(object)
Как создается объект?
a = A(1, 2)
Аналогично a = type.__call__(A, 1, 2)
Внутри как-то так:
def __call__(obj_type, *args, **kwargs):
    obj = obj_type.__new__(*args, **kwargs)
    if obj is not None and issubclass(obj, obj_type):
        obj.__init__(*args, **kwargs)
    return obj
__new__ выделяет нам память и возвращает объект нужного типа
Как питон ищет аттрибуты у объекта?
У объекта есть поле __dict__
Сначала смотрим в object.__dict__
Затем в аттрибуты класса: object.__class__.__bases__.__dict__
Пример использования property - в коде

Интересные методы:
__bool__ отвечает за if (object)
__contains__         item in object
__call__ отвечает за object(). Не за класс()!

MRO - method resolution order
Линеаризация производится алгоритмом C3
Класс - это шаблон для создания объеков, а метакласс - шаблон для создания классов
На самом деле, метаклассы не особо нужны, потому что вместо них лучше пользоваться наследованием,
ну или декораторами классов
############модуль abc
Позволяет реализовывыать интерфейсы. Для этого есть класс ABC.
Наследуемся от него, пишем методы, которые должны быть в классе, реализующем интерфейс и декорируем их с помощью
@abstractmethod. Теперь нельзя будет создать класс и не реализовать эти методы
#############collections.abc
Абстракные бК для коллекций. Можем унаследоваться и написать свою.
Например, Set, Collection, Callable и т.д.
#############inspect
inspect.getsourcelines(object) - посмотреть исходник объекта
.signature(object) - получить сигнартуру callable объекта. Например, функции
